---
title: "PAC2-òmiques"
author: "Joan Serrano Quílez"
date: "`r format(Sys.time(), '%d %B, %Y')`"
lang: es-ES
output: 
  pdf_document:
    toc: yes
    toc_depth: 3
urlcolor: blue
editor_options: 
  chunk_output_type: console
---


```{r echo = FALSE, message = FALSE}
if(!require(BiocManager)) install.packages("BiocManager")
if(!require(DESeq2)) BiocManager::install("DESeq2")
if(!require(DESeq2)) BiocManager::install("apeglm")
if(!require(genefilter)) BiocManager::install("genefilter")
if(!require(org.Hs.eg.db)) BiocManager::install("org.Hs.eg.db")
if(!require(AnnotationDbi)) BiocManager::install("AnnotationDbi")
if(!require(dplyr)) install.packages("dplyr", dep = TRUE)
if(!require(ggplot2)) install.packages("ggplot2", dep = TRUE)
if(!require(pheatmap)) install.packages("pheatmap", dep = TRUE)
```

L’arxiu executable d’aquest treball és pot trobar a github a l’adreça web: https://github.com/joaseki/PEC2_ADO



# 1. Resum

# 2. Objectius

L'objectiu d'aquest estudi utilitzant dades de RNA-seq és el d'analitzar i identificar possibles efectes d'infiltració en tiroides, bé amb infiltrats locals o amb extensius en limfòcits. Així podem dividir l'objectiu com a doble:

- D'una banda saber si cadascun dels tractaments resulta eficaç pels pacients.
- Saber si existeixen diferències entre els dos tractaments esmentats.

# 3. Materials i mètodes

## 3.1. Dades i disseny experimental

Les dades emprades han estat proporcionades pel professor i provenen de dades d'expressió obtingudes per **RNA-Seq**. Es troben en un parell d'arxius, **targets.csv** que conté la informació de cada mostra, sobre el seu grup i d'altres característiques. D'altra banda, **counts.csv** que conté els contejos per a cada geni mostra.
Els arxius originals contenen un total de 292 mostres, però de manera pseudoaleatòria s'extreuen 10 mostres de cada grup, com s'explica a l'apartat següent, per tant se'ns queden un total de 30 mostres distribuïdes de la següent manera:

- 10 mostres de teixits no infiltrats (a partir d'ara, **NIT**)
- 10 mostres d'infiltrats locals petits (a partir d'ara, **SFI**)
- 10 mostres d'infiltrats extensius limfoides (a partir d'ara, **ELI**)

Per tant, l'experimetn que tenim davant és del tipus de **comparació de classes**, ja que volem veure com canvia l'expressió dels gens entre els diferents grups, tal com s'ha dit als Objectius. Pel que fa al disseny experimental, tindria només un factor en aquest cas (A) que seria el tipus de tractament, d'*efectes fixes** (ja que només s'estudien aquests), amb 3 nivells (NIT, SFI i ELI). Podríem fàcilment representar aquest disseny experimental amb l'equació:
$$y_{ij} = \mu + \alpha_{i} + \epsilon_{ij} $$
On $\mu$ seria la mitjana general per a un gen determinat, $\alpha_{i}$ és l'efecte de cadascun dels tres tipus de tractament $i$, $\epsilon_{ij}$ els errors aleatoris per a cada tractament *i* i rèplica *j*. Per tant, $y_{ij}$ és l'expressió per a un gen determinat en una observació i grup determinat, que per tant, anirà determinat pel grup a què pertany. 

Una vegada hem establert quin hauria de ser el disseny experimental, procedim a assenyalar quin haurien de ser els contrastos d'interès:

- $\alpha_{NIT}$ vs $\alpha_{SFI}$: per a veure si el tractament amb SFI té un efecte sobre no tractats;
- $\alpha_{NIT}$ vs $\alpha_{ELI}$: per a veure si el tractament amb ELI té un efecte sobre els no tractats i, per últim;
- $\alpha_{SFI}$ vs $\alpha_{ELI}$: per a comprovar si ambdós tractaments mostren diferències entre sí.


## 3.2. Mètodes i eines emprades

### 3.2.1. Procediment general d'anàlisi
El *work-flow* que s'ha fet servir és molt semblant al trobat a l'enunciat de la PAC:

 - 1. Obtenció pseudoaleatòria de les dades
 - 2. Preprocesament de les dades: filtratge i normalització
 - 3. Identificació de gens diferencialment expressats
 - 4. Anotació de resultats
 - 5. Agrupació entre mostres
 - 6. Anàlisi de significació biològica
 
### 3.2.2. Software emprat
Durant aquest estudi, el *software* que s'ha decidit fer servir és **R**, en concret s'ha emprat el paquet **DESeq2**, que ens permet fer un anàlisi complet de les dades, obtenint la seva significació biològica.

## 3.3. Descripció pas a pas
En primer lloc, s'ha procedit a l'extracció aleatòria de les dades. Tanmateix, no s'ha fet de manera totalment aleatòria, sinó que amb la fi de poder traballar sempre amb les mateixes dades i que aquestes no canviessin massa, s'ha fet un *set.seed()* (ficant com a número el meu NIF), de manera que les dades triades serien, en tot cas, *pseudoaleatòries*. 



## Data preparation

```{r echo = FALSE, message=FALSE, include = FALSE}
targets <- read.csv("Data/targets.csv")
counts <- read.table("Data/counts.csv", sep = ";", header = T, check.names = F)

set.seed(21701867)
NIT <- subset(targets, targets$Group == "NIT")
NIT_sampled <- NIT[sample(1:236, 10),]
SFI <- subset(targets, targets$Group == "SFI")
SFI_sampled <- SFI[sample(1:42, 10),]
ELI <- subset(targets, targets$Group == "ELI")
ELI_sampled <- ELI[sample(1:14, 10),]

sampled_targets <- rbind(NIT_sampled, SFI_sampled, ELI_sampled)

sampled_counts <- counts[,sampled_targets$Sample_Name]
rownames(sampled_counts) <- counts[,1]

colnames(sampled_counts)[1:10] <- paste0("NIT", 1:10)
colnames(sampled_counts)[11:20] <- paste0("SFI", 11:20)
colnames(sampled_counts)[21:30] <- paste0("ELI", 21:30)

rownames(sampled_counts) <- gsub("\\..*", "",rownames(sampled_counts), fixed = FALSE)
coldata <- sampled_targets[,c("Group", "Grupo_analisis")]
```



```{r cars}
library("DESeq2")
dds <- DESeqDataSetFromMatrix(countData = sampled_counts,
                              colData = coldata,
                              design = ~ Group)
featureData <- data.frame(gene = rownames(sampled_counts))
mcols(dds) <- DataFrame(mcols(dds), featureData)
mcols(dds)
```



```{r}
#Prefiltering
keep <- rowSums(counts(dds)) >= 10
dds <- dds[keep,]
```

```{r}
##transfromations
vsd <- vst(dds, blind=FALSE)
rld <- rlog(dds, blind=FALSE)
library(dplyr)
library(ggplot2)
dds <- estimateSizeFactors(dds)
dds1 <- dds

df <- bind_rows(
  as_data_frame(log2(counts(dds, normalized=TRUE)[, 1:2]+1)) %>%
         mutate(transformation = "log2(x + 1)"),
  as_tibble(assay(vsd)[, 1:2]) %>% mutate(transformation = "vst"),
  as_tibble(assay(rld)[, 1:2]) %>% mutate(transformation = "rlog"))
```

```{r}
colnames(df)[1:2] <- c("x", "y")  

ggplot(df, aes(x = x, y = y)) + geom_hex(bins = 80) +
  coord_fixed() + facet_grid( . ~ transformation)
```

```{r}
dds <- DESeq(dds)
resS_E <- results(dds, name = "Group_SFI_vs_ELI", )
resN_E <- results(dds, name = "Group_NIT_vs_ELI")
dds1$Group <- relevel(dds$Group, "NIT")
dds1 <- DESeq(dds1)
resS_N <- results(dds1, name = "Group_SFI_vs_NIT")
```

```{r}
resSigS_E <- subset(resS_E, padj <0.1)
resSigN_E <- subset(resN_E, padj <0.1)
resSigS_N<- subset(resS_N, padj <0.1)
```

```{r}
annotate_symbol <- function(res){
  library(AnnotationDbi)
  library(org.Hs.eg.db)
  res$symbol <- mapIds(org.Hs.eg.db,
                     keys=row.names(res),
                     column="SYMBOL",
                     keytype="ENSEMBL",
                     multiVals="first")
  return(res$symbol)
}

resS_E$symbol <- annotate_symbol(resS_E)
resN_E$symbol <- annotate_symbol(resN_E)
resS_N$symbol <- annotate_symbol(resS_N)
```

```{r}
sampleDists <- dist(t(assay(vsd)))
library(pheatmap)
library("RColorBrewer")
sampleDistMatrix <- as.matrix(sampleDists)
rownames(sampleDistMatrix) <- vsd$Group
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix,
         clustering_distance_rows=sampleDists,
         clustering_distance_cols=sampleDists,
         col=colors)
```

```{r}
pcaData <- plotPCA(vsd, intgroup= "Group", returnData=TRUE)
percentVar <- round(100 * attr(pcaData, "percentVar"))
ggplot(pcaData, aes(PC1, PC2, color=Group)) +
  geom_point(size=3) +
  xlab(paste0("PC1: ",percentVar[1],"% variance")) +
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + 
  coord_fixed() + theme_classic()
```

```{r}
library("genefilter")
topVarGenes <- head(order(rowVars(assay(vsd)), decreasing = TRUE), 20)

mat  <- assay(vsd)[topVarGenes, ]
mat  <- mat - rowMeans(mat)
anno <- as.data.frame(colData(vsd)[, c("Group","Grupo_analisis")])
pheatmap(mat, annotation_col = anno, cluster_cols = T)
```

```{r}
plotMA(resS_E, ylim = c(-5,5))
plotMA(resN_E, ylim = c(-5,5))
plotMA(resS_N, ylim = c(-5,5))
```

```{r}
resOrderedS_E <- resS_E[order(resS_E$pvalue),]

resOrderedN_E <- resN_E[order(resN_E$pvalue),]

resOrderedS_N <- resS_N[order(resS_N$pvalue),]
```
```{r fig.align='center', fig.width=7, fig.height=7}
library(DOSE)
ego_creator <- function(res){
  
  geneList <- res$log2FoldChange
  names(geneList) <- as.character(res$symbol)
  geneList<- sort(geneList, decreasing = T)
  library(clusterProfiler)
  de <- names(geneList)[abs(geneList) > 1]
  ego <- enrichGO(gene         = de,
                OrgDb         = org.Hs.eg.db,
                keyType       = 'SYMBOL',
                ont           = "BP",
                pAdjustMethod = "BH")
  return(ego)
}
egoS_E <- ego_creator(resS_E)
egoN_E <- ego_creator(resN_E)
egoS_N <- ego_creator(resS_N)
library(enrichplot)
library(ggupset)


upsetplot(egoS_E)
upsetplot(egoN_E)
upsetplot(egoS_N)
```


